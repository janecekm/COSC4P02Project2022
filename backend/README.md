# Backend Infrastructure
Our backend is uses technologies such as flask, flask-sqlalchemy, pytest, docker, spacy, symspell, coverage and heroku. 

## Flask
Flask is a web development framework built for Python. It helps simplify handling server processes such as serving frontend, doing backend processes and so on. More documentation can be read [here](https://flask.palletsprojects.com/en/2.1.x/)

The files that use this are 
- [Server](server.py)
- [Development Server](devserver.py)

Where GET and POST requests are handled seperately by different processes, which helps which maintaining segmentation between backend and frontend.

We can run this by using the command:

>`python ./devserver.py`

This will run the development server, which uses files built by the npm from [chatbot](../chatbot/) folder into [static](./static/) folder. The development server is used for all development and testing work.

When the system is ready to be deployed, the backend folder is copied into a container by using Docker and the server ([server.py](server.py)) is run by the container in the deployment environment. 

## Pytest

This framework is used to perform testing for our software. You can read more documentation [here](https://docs.pytest.org/en/7.1.x/). The way this works is it finds the files which starts from test_*.py. The testing files are split up such that each file tests a single core function of the system. This helps us to ensure that each function produces the appropriate results and helps to pinpoint errors should something fail.

The commands to run if you are on Windows is:
> python -m pytest .

However, if you have Linux environment installed, the command to run is:
> pytest .
 
 The naming convention we use is 
 > test_sitename_function.py

 Then we use a package called Coverage to test how much of the code is tested by the tests we have set up.

 ## Coverage

This is a framework developed to help developers measure how much of the code has been tested by the [pytest](#pytest) framework. You can read more about Coverage [here](https://coverage.readthedocs.io/en/6.3.2/)

To run Coverage:

For Windows 
> python -m coverage run -m pytest .

For Linux environment
> coverage run -m pytest .

There are many ways to view the final report generated by Coverage. To view the report from the command line, use: 
> coverage report

## Docker
Docker is an amazing tool, which can be used to containerize software to easily be able to be deployed into different environment or platforms. 

You can read more about Docker [here](https://www.docker.com/)

The file in which our image is contained is:

- [DockerFile](../Dockerfile)

This has to exist in the most external folder so that the environment we are deploying into can grab that file easily.

## NLP

### SpaCy

SpaCy is a Python package for "industrial strength natural language processing". We use this package to handle all of the NLP tasks for our chatbot. You can read more about spaCy [here](https://spacy.io/). 

Our software primarily relies on pattern matching to extract keyword information from user queries. We do this by using spaCy's `Matcher` for token-based matching and `PhraseMatcher` for efficient case-insensitive matching for longer lists of phrases. For more information on how these matchers work refer to their documentation pages: [Matcher](https://spacy.io/api/matcher), [PhraseMatcher](https://spacy.io/api/phrasematcher). For additional support, refer to the [rule-based matching guide](https://spacy.io/usage/rule-based-matching). 

Since the keyword matches for user queries are dependent on which chatbot is being used (Brock or Canada Games), the match patterns for the `Matcher` and `PhraseMatcher` are defined in separate files, which can be loaded depending on which chatbot is being used. These files are [brockMatcher.py](brockMatcher.py) and [canadaMatcher.py](canadaMatcher.py), respectively. 

### SymspellPy

[SymspellPy](https://pypi.org/project/symspellpy/) is used to perform spelling correction on user queries. Documentation for SymspellPy is available [here](https://symspellpy.readthedocs.io/en/latest/).

To handle the unique terminology required by the Brock chatbot (like course and building codes and names of locations unique to Brock or the Niagara Region) we load a custom dictionary for use with SymspellPy. This dictionary, [frequency_dictionary_en_82_765.txt](./nlp-resources/frequency_dictionary_en_82_765.txt), contains words and their corresponding frequency weights, and is based off of the dictionary that ships with SymspellPy. To add the unique terms, we simply added entries to the dictionary's .txt file with weights chosen based on approximations of how frequently they may appear in the chatbot, relative to other terms. These frequencies can be adjusted based on usage and observation to improve accuracy. 

### General Structure 

The main entry point into processing user questions is in [botNLP.py](botNLP.py). botNLP receives the user query string and loads the appropriate matcher information based on the flag provided from the server. The user query is spellcorrected using Symspell and then processed through the NLP pipeline and the appropriate matchers to generate the list of keywords. These keywords are then processed so they can be used to query the database using the `doQueries()` function for the Brock chatbot or the `cgQueries()` function for the Canada Games chatbot from [queryTables.py](queryTables.py). 

Once data is returned from the database, we form a response based on the extracted keywords and the database response (what data we received, if any), using `formResponse()`. Since the types of responses are dependent upon which chatbot being used, there `brockMatcher.py` and `canadaMatcher.py` each have a unique implementation of this function.  

There are three main categories of response that the chatbot gives: 
1) Responses using information from the database
2) Link responses
3) Ask-again responses

For types 1 and 2, information is substituted into an appropriate template string either based on the information supplied from the database or from the links table, respectively. The third type of response occurs when we are not able to determine a suitable answer for the question from either the database or the links table. 

Once the response string has been generated, `botNLP.py` returns it to the server as a dictionary of the form `{"message":"response"}` where `response` is the desired response string. 